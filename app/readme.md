# Logbook

Inside this logbook you will find how we managed to solve the given tasks.

Every task has a subset of subtasks, in developing the solution for the specified task we marked down how we solved them step-by-step, finally implementing the requested functionality.

The majority of functions has been developed by using the “Test Driven Development” method.

## Image histogram (#1)

### Copy the classification API form and modify it where it is required.

- Once we created the unit test for the new form, we created the `ClassificationFormHistogram` class, which contains only one attribute, `image_id`, which is the id selected by the new html page. We then created the HTML page `classification_select_histogram`, which is virtually identical to the `classification_select` page, only it has only one select to select the image.
- In the navbar we’ve added the new form, via a new GET endpoint `/classifications_histogram`.

### Implement the new API that takes as input the id of an image and returns the histogram.

- Inside the [main.py](http://main.py/) file, we’ve created the endpoint to send the image_id from the `classification_select_histogram` file. Here we’ve fetched the image from the folder using the method `fetch_image_file(image_id)` and converted it in a BASE64 string. Finally we have returned the image_id and the base64 string.

### Visualize the histogram and the image in the GUI.

- Once we created the acceptance tests using soup4 ([beautifulsoup4 · PyPI](https://pypi.org/project/beautifulsoup4/)), we’ve created the `classification_output_histogram` html file that contains a canvas, the canvas shows the plot generated by a Javascript file:
1. Using jQuery to wait for the document to be ready, we retrieve the base64-encoded image string from the HTML element with the `makeHistogram` id, creates an Image object, sets the image source, and then calls a function to calculate the RGB histogram once the image is loaded.
2. The **`calculateRGBHistogram`** function processes the pixel data of the loaded image, incrementally updating a 2D array representing the RGB histogram. It then returns the calculated histogram.
3. The **`drawRGBHistogramWithChartJS`** function uses Chart.js to create a bar chart representing the RGB histogram. It configures the chart with appropriate labels, colors, and axis titles, and then renders it on a canvas element with the id 'histogramCanvas'.

Inside the html file we included the back button and the selected image.

## Image trasformation (#2)

### Copy the classification API interface.

- We copied the classification API interface

### Create a form for selecting the transformation.

- We have created a new form to manage the classify transform. It shows the dropdown menu to select the image, the submit button and one field for each transformation (Color, Brightness , Contrast and Sharpness) that allows specifying values for the transformation to apply . The values for the transformation have default, min and max values : -for Color the min value is 0.0 , the max value is 1.0 and the default value is 1.0 -for Brightness the min value is 0..0 , the max value is 1.0 and the default value is 1.0 -for Contrast the min value is 0.0 , the max value is 1.0 and the default value is 1.0 -for sharpness the min value is 0.0 , the max value is 2.0 and the default value is 1.0 but this fields can be changed by the user in increments or decrements of 0.01

### Implement the API that applies the transformation to the selected image.

- After the test , using BeautifulSoup , has been made , we have created an API inside the [main.py](http://main.py/) file . The function takes the input parameters for image transformation (Color , Brightness , Contrast , Sharpness) , applies these transformation to the selected image using ImageEnhance, saves the modified image to a temporary file , performs classification on the transformed image and then returns a TemplateResponse. This response triggers the visualization of the results in the classification_output.html template

### Implement the visualization of results.

- The request_classification_transform function implements also the visualization of results with the TemplateResponse returned. It passes the necessary data (image_id , classification_scores , request) to the classification_output.html template to be rendered and displayed to the user

## Download results (#3)

### Add the "download results" button to the interface.

- Once the test has been made, we have develope the buttons in the HTML page and made some edit in the test so they can use the <a> tag instead of <button> with href. Also changed the button style to make it look *fancier*.

### Add the "download plot" button to the interface.

- Similar to the previous subtask, we added another button for download the plot generated dinamically.

### Implement the API for returning a JSON file with the results.

- Once the test has been made, we have develope an API using the [main.py](http://main.py/) file that allow us to save the file in our directory once the classification has been made and then retrieving it once the api has been called.

### Implement the API for returning the plot.

- For this function we used a sligthly different approach, the plot is dinamically generated once the classification has been made, so we retrieved the canva from the html with a js function that make a call to an api endpoint sending the data plot to it, the api then retrieve the data of the plot, make an image out of this data and then send back to the js the file to be downloaded. The js function take the image given by the api and simulate the event of clicking once appending the file to the site and downloading it.

### Connect the buttons with the APIs.

- Finally, once the html button is pressed we call this api endpoint functions. After that this function has been tested successfully and then commented with appropriate docstring.

## Upload immage button (#4)

### Copy the route and HTML file of the classification API.

- We’ve copied the /classifications route from file [main.py](http://main.py/) in the first version of the repository. We’ve created a new route, called “/upload-and-classify” able to do both post and get requests. Then we have added the new html file “classification_upload_image” to handle the new request.

### Add the new route to the routes init file.

- As mentioned in the previous subtask, we’ve copied the route of classifications and put that in the [main.py](http://main.py) file so it is now reachable.

### Add "upload" button in the frontend (HTML).

- In the new HTML page we’ve created all the necessary buttons to handle the function to upload the desired file to classify.

### Implement the API for storing the image

- Once the tests has been made, we have develope an API using the [main.py](http://main.py/) file that allow us to retrieve image loaded and the id from the form, classify the image and then send the result to the user. All the work is done by the HTML page that take an input file as image and send it to the user. The image is read by the Classification upload form in bytes.

### Pass the image to the classification API.

- Once the image has been classified, we can encode the loaded image in base64. It's useful to exploit html <img> tag with src="...;base64= ...” then send it to the usual classified page in HTML.
